{"version":3,"file":"update-group.js","sourceRoot":"","sources":["update-group.ts"],"names":[],"mappings":";;AAEA,4CAAoD;AACpD,kCAA8H;AAM9H,kCAA2D,SAAiC;IAC1F,MAAM,CAAC,UAAC,KAA6B;QACnC,IAAI,UAAU,GAAG,KAAK,CAAC;QACvB,IAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,GAAG;YAC9D,IAAM,OAAO,GAAG,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;YACpC,GAAG,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC;YACnB,EAAE,CAAC,CAAC,SAAS,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBAClC,IAAM,UAAU,GAAG,SAAS,CAAC,GAAG,CAAE,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;gBACnD,UAAU,GAAG,UAAU,IAAI,UAAU,KAAK,OAAO,CAAC;gBAClD,GAAG,CAAC,GAAG,CAAC,GAAG,UAAU,CAAC;YACxB,CAAC;YACD,MAAM,CAAC,GAAG,CAAC;QACb,CAAC,EAAE,EAA+B,CAAC,CAAC;QACpC,MAAM,CAAC,UAAU,GAAG,WAAW,GAAG,KAAK,CAAC,QAAQ,CAAC;IACnD,CAAC,CAAC;AACJ,CAAC;AAED,2BAAoD,SAAiC;IACnF,MAAM,CAAC,UAAC,KAA6B;QACnC,IAAM,WAAW,GAAG,wBAAwB,CAAS,SAAS,CAAC,CAAC,KAAK,CAAC,CAAC;QACvE,MAAM,CAAC,WAAW,KAAK,KAAK,CAAC,QAAQ;cACjC,yBAAiB,CAAS,KAAK,CAAC,EAAE,EAAE,WAAW,EAAE,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,kBAAkB,EAAE,KAAK,CAAC,qBAAqB,CAAC;cAClI,KAAK,CAAC;IACZ,CAAC,CAAC;AACJ,CAAC;AAwED,qBACE,eAAgE;IAChE,sBAA8C;SAA9C,UAA8C,EAA9C,qBAA8C,EAA9C,IAA8C;QAA9C,qCAA8C;;IAE9C,EAAE,CAAC,CAAC,oBAAY,CAAC,eAAsB,CAAC,CAAC,CAAC,CAAC;QAClC,IAAA,uBAAK,EAAE,4BAAO,CAAiB;QACtC,MAAM,CAAC,WAAW,gBAAC,KAAK,SAAK,IAAI,GAAE,eAAsB,CAAC,CAAC;IAC7D,CAAC;IAED,MAAM,CAAC,UAAC,KAA6B;QACnC,MAAM,CAAC,CAAC,eAAsB,SAAK,YAAY,EAAE,MAAM,CAAC,UAAC,CAAC,EAAE,QAAQ,IAAK,OAAA,iBAAiB,CAAS,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAtC,CAAsC,EAAE,KAAK,CAAC,CAAC;IAC1H,CAAC,CAAC;AACJ,CAAC;AAZD,kCAYC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BG;AACH;IAA0E,sBAA8C;SAA9C,UAA8C,EAA9C,qBAA8C,EAA9C,IAA8C;QAA9C,iCAA8C;;IACtH,MAAM,CAAC,UAAC,KAA6B,EAAE,MAAc;QACnD,KAAK,GAAG,0BAAgB,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QACxC,MAAM,CAAC,WAAW,eAAY,YAAY,EAAE,KAAK,CAAC,CAAC;IACrD,CAAC,CAAC;AACJ,CAAC;AALD,4EAKC","sourcesContent":["import { Action } from '@ngrx/store';\n\nimport { formGroupReducer } from '../group/reducer';\nimport { AbstractControlState, computeGroupState, FormGroupControls, FormGroupState, KeyValue, isGroupState } from '../state';\nimport { ProjectFn2 } from './util';\n\nexport type StateUpdateFns<TValue extends KeyValue> =\n  {[controlId in keyof TValue]?: ProjectFn2<AbstractControlState<TValue[controlId]>, FormGroupState<TValue>> };\n\nfunction updateGroupControlsState<TValue extends KeyValue>(updateFns: StateUpdateFns<TValue>) {\n  return (state: FormGroupState<TValue>) => {\n    let hasChanged = false;\n    const newControls = Object.keys(state.controls).reduce((res, key) => {\n      const control = state.controls[key];\n      res[key] = control;\n      if (updateFns.hasOwnProperty(key)) {\n        const newControl = updateFns[key]!(control, state);\n        hasChanged = hasChanged || newControl !== control;\n        res[key] = newControl;\n      }\n      return res;\n    }, {} as FormGroupControls<TValue>);\n    return hasChanged ? newControls : state.controls;\n  };\n}\n\nfunction updateGroupSingle<TValue extends KeyValue>(updateFns: StateUpdateFns<TValue>) {\n  return (state: FormGroupState<TValue>): FormGroupState<TValue> => {\n    const newControls = updateGroupControlsState<TValue>(updateFns)(state);\n    return newControls !== state.controls\n      ? computeGroupState<TValue>(state.id, newControls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties)\n      : state;\n  };\n}\n\n/**\n * This update function takes a variable number of update function objects and\n * returns a projection function that applies all objects one after another to\n * a form group state.\n *\n * The following (contrived) example uses this function to validate the child\n * control `name` to be required and set the child control `email`'s value to\n * be `''` if the name is invalid.\n *\n * ```typescript\n * interface FormValue {\n *   name: string;\n *   email: string;\n * }\n *\n * const groupUpdateFn = updateGroup<FormValue>(\n *   {\n *     name: validate(required),\n *   },\n *   {\n *     email: (email, parentGroup) =>\n *       parentGroup.controls.name.isInvalid\n *         ? setValue('', email)\n *         : email,\n *   },\n * );\n * const updatedState = groupUpdateFn(state);\n * ```\n */\n// the weird return type is necessary to allow using updateGroup inside of updateGroup\n// and with optional controls\nexport function updateGroup<TValue>(\n  ...updateFnsArr: Array<StateUpdateFns<TValue>>,\n): (state: FormGroupState<TValue> | AbstractControlState<TValue | undefined>) => FormGroupState<TValue>;\n\n/**\n * This update function takes a form group state and a variable number of update\n * function objects and applies all objects one after another to the state.\n * Providing multiple update function objects is mainly useful if the result\n * of a later object depends on the result of previous objects.\n *\n * The following (contrived) example uses this function to validate the child\n * control `name` to be required and set the child control `email`'s value to\n * be `''` if the name is invalid.\n *\n * ```typescript\n * interface FormValue {\n *   name: string;\n *   email: string;\n * }\n *\n * const updatedState = updateGroup<FormValue>(\n *   state,\n *   {\n *     name: validate(required),\n *   },\n *   {\n *     email: (email, parentGroup) =>\n *       parentGroup.controls.name.isInvalid\n *         ? setValue('', email)\n *         : email,\n *   },\n * );\n * ```\n */\nexport function updateGroup<TValue>(\n  state: FormGroupState<TValue>,\n  ...updateFnsArr: Array<StateUpdateFns<TValue>>,\n): FormGroupState<TValue>;\n\nexport function updateGroup<TValue extends KeyValue>(\n  stateOrFunction: FormGroupState<TValue> | StateUpdateFns<TValue>,\n  ...updateFnsArr: Array<StateUpdateFns<TValue>>,\n) {\n  if (isGroupState(stateOrFunction as any)) {\n    const [first, ...rest] = updateFnsArr;\n    return updateGroup(first, ...rest)(stateOrFunction as any);\n  }\n\n  return (state: FormGroupState<TValue>): FormGroupState<TValue> => {\n    return [stateOrFunction as any, ...updateFnsArr].reduce((s, updateFn) => updateGroupSingle<TValue>(updateFn)(s), state);\n  };\n}\n\n/**\n * This function creates a reducer function that first applies an action to the state\n * and afterwards applies all given update function objects one after another to the\n * resulting form group state.\n *\n * The following (contrived) example uses this function to create a reducer that after\n * each action validates the child control `name` to be required and sets the child\n * control `email`'s value to be `''` if the name is invalid.\n *\n * ```typescript\n * interface FormValue {\n *   name: string;\n *   email: string;\n * }\n *\n * const reducer = createFormGroupReducerWithUpdate<FormValue>(\n *   {\n *     name: validate(required),\n *   },\n *   {\n *     email: (email, parentGroup) =>\n *       parentGroup.controls.name.isInvalid\n *         ? setValue('', email)\n *         : email,\n *   },\n * );\n * ```\n */\nexport function createFormGroupReducerWithUpdate<TValue extends KeyValue>(...updateFnsArr: Array<StateUpdateFns<TValue>>) {\n  return (state: FormGroupState<TValue>, action: Action) => {\n    state = formGroupReducer(state, action);\n    return updateGroup<TValue>(...updateFnsArr)(state);\n  };\n}\n"]}