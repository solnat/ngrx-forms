{"version":3,"file":"state.js","sourceRoot":"","sources":["state.ts"],"names":[],"mappings":"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","sourcesContent":["import { isEmpty } from './util';\r\n\r\nexport type FormControlValueTypes = string | number | boolean | null | undefined;\r\nexport type NgrxFormControlId = string;\r\n\r\n/**\r\n * This type represents a collection of named errors.\r\n */\r\nexport interface ValidationErrors { [key: string]: any; }\r\nexport interface KeyValue { [key: string]: any; }\r\n\r\n/**\r\n * Base interface for all types of form states.\r\n */\r\nexport interface AbstractControlState<TValue> {\r\n  /**\r\n   * The unique ID of the form state. Usually this is the name or index\r\n   * of the control in the form value prefixed by the ID of the containing\r\n   * group or array, e.g. `MY_FORM.someTextInput` or `MY_FORM.0`.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * The value of the form state.\r\n   */\r\n  value: TValue;\r\n\r\n  /**\r\n   * This property is `true` if the state does not have any errors.\r\n   */\r\n  isValid: boolean;\r\n\r\n  /**\r\n   * This property is `true` if the state has at least one error.\r\n   */\r\n  isInvalid: boolean;\r\n\r\n  /**\r\n   * The errors of the state. This property always has a value.\r\n   * If the state has no errors the property is set to `{}`.\r\n   */\r\n  errors: ValidationErrors;\r\n\r\n  /**\r\n   * The names of all asynchronous validations currently running\r\n   * for the state.\r\n   */\r\n  pendingValidations: string[];\r\n\r\n  /**\r\n   * This property indicates whether the control is currently being\r\n   * asynchronously validated.\r\n   */\r\n  isValidationPending: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the state is enabled. When it\r\n   * is `false` the `errors` are always `{}` (i.e. the state is\r\n   * always valid if disabled) and `pendingValidations` is always `[]`\r\n   * (i.e. all pending validations are cancelled).\r\n   */\r\n  isEnabled: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the state is disabled. When it\r\n   * is `true` the `errors` are always `{}` (i.e. the state is\r\n   * always valid if disabled) and `pendingValidations` is always `[]`\r\n   * (i.e. all pending validations are cancelled).\r\n   */\r\n  isDisabled: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the state's value changes.\r\n   */\r\n  isDirty: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the state's value never changed.\r\n   */\r\n  isPristine: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the state is touched.\r\n   */\r\n  isTouched: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the state is not touched.\r\n   */\r\n  isUntouched: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the state is submitted.\r\n   */\r\n  isSubmitted: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the state is not submitted.\r\n   */\r\n  isUnsubmitted: boolean;\r\n\r\n  /**\r\n   * This property is a container for user-defined metadata (e.g. if\r\n   * you wanted to count the number of times a state's value has been\r\n   * changed, what keys were pressed on an input, or how often a form\r\n   * has been submitted etc.). While it is possible to store this kind\r\n   * of information outside of `ngrx-forms` in your own state the\r\n   * `userDefinedProperties` allow you to store your own metadata\r\n   * directly in the state.\r\n   */\r\n  userDefinedProperties: KeyValue;\r\n}\r\n\r\n/**\r\n * State associated with a form control, i.e. an HTML form\r\n * element in the view (e.g. `input`, `select`, `textarea` etc.).\r\n */\r\nexport interface FormControlState<TValue extends FormControlValueTypes> extends AbstractControlState<TValue> {\r\n  /**\r\n   * The value of the form state. Form controls only support values of\r\n   * type `string`, `number`, `boolean`, `null`, and `undefined` to\r\n   * keep the state string serializable.\r\n   */\r\n  value: TValue;\r\n\r\n  /**\r\n   * This property is `true` if the form control does not have any errors.\r\n   */\r\n  isValid: boolean;\r\n\r\n  /**\r\n   * This property is `true` if the form control has at least one error.\r\n   */\r\n  isInvalid: boolean;\r\n\r\n  /**\r\n   * The errors of the form control. This property always has a value.\r\n   * If the control has no errors the property is set to `{}`.\r\n   */\r\n  errors: ValidationErrors;\r\n\r\n  /**\r\n   * The names of all asynchronous validations currently running for the\r\n   * form control.\r\n   */\r\n  pendingValidations: string[];\r\n\r\n  /**\r\n   * This property indicates whether the control is currently being\r\n   * asynchronously validated (i.e. this is `true` if and only if\r\n   * `pendingValidations` is not empty).\r\n   */\r\n  isValidationPending: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the form control is enabled.\r\n   * When it is `false` the `errors` are always `{}` (i.e. the form\r\n   * control is always valid if disabled) and `pendingValidations`\r\n   * is always `[]` (i.e. all pending validations are cancelled).\r\n   */\r\n  isEnabled: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the form control is disabled.\r\n   * When it is `true` the `errors` are always `{}` (i.e. the form\r\n   * control is always valid if disabled) and `pendingValidations`\r\n   * is always `[]` (i.e. all pending validations are cancelled).\r\n   */\r\n  isDisabled: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the underlying\r\n   * `FormViewAdapter` or `ControlValueAccessor` reports a new\r\n   * value for the first time.\r\n   */\r\n  isDirty: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the underlying\r\n   * `FormViewAdapter` or `ControlValueAccessor` has never\r\n   * reported a new value.\r\n   */\r\n  isPristine: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` based on the rules of the\r\n   * underlying `FormViewAdapter` (usually on `blur` for most form\r\n   * elements).\r\n   */\r\n  isTouched: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the control is not touched.\r\n   */\r\n  isUntouched: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the group or array\r\n   * containing this form control is submitted. A form control can\r\n   * never be submitted on its own.\r\n   */\r\n  isSubmitted: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the state is not submitted.\r\n   */\r\n  isUnsubmitted: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` if the form control currently\r\n   * has focus. This feature is opt-in. To enable it you have to\r\n   * enable it for a given form element like this:\r\n   *\r\n   * ```html\r\n   * <input [ngrxFormControlState]=\"state\"\r\n   *       [ngrxEnableFocusTracking]=\"true\" />\r\n   * ```\r\n   */\r\n  isFocused: boolean;\r\n\r\n  /**\r\n   * This property is `true` if the control currently does not have\r\n   * focus or focus tracking is not enabled for the form control.\r\n   */\r\n  isUnfocused: boolean;\r\n}\r\n\r\n/**\r\n * This type represents the child control states of a form group.\r\n */\r\nexport type FormGroupControls<TValue> = {[controlId in keyof TValue]: AbstractControlState<TValue[controlId]> };\r\n\r\n/**\r\n * Form groups are collections of named controls. Just like controls\r\n * groups are represented as plain state objects. The state of a\r\n * group is determined almost fully by its child states.\r\n */\r\nexport interface FormGroupState<TValue extends KeyValue> extends AbstractControlState<TValue> {\r\n  /**\r\n   * The aggregated value of the form group. The value is computed by\r\n   * aggregating the values of all children, e.g.\r\n   *\r\n   * ```typescript\r\n   * {\r\n   *   child1: 'some value',\r\n   *   child2: {\r\n   *     nestedChild: 10,\r\n   *   },\r\n   * }\r\n   * ```\r\n   */\r\n  value: TValue;\r\n\r\n  /**\r\n   * This property is `true` if the form group does not have any errors\r\n   * itself and none of its children have any errors.\r\n   */\r\n  isValid: boolean;\r\n\r\n  /**\r\n   * This property is `true` if the form group or any of its children\r\n   * have at least one error.\r\n   */\r\n  isInvalid: boolean;\r\n\r\n  /**\r\n   * The errors of the form group. This property is computed by merging\r\n   * the errors of the group with the errors of all its children where\r\n   * the child errors are a property of the `errors` object prefixed with\r\n   * an underscore, e.g.\r\n   *\r\n   * ```\r\n   * {\r\n   *   groupError: true,\r\n   *   _child: {\r\n   *     childError: true,\r\n   *   },\r\n   * }\r\n   * ```\r\n   *\r\n   * If neither the group nor any children have errors the property is\r\n   * set to `{}`.\r\n   */\r\n  errors: ValidationErrors;\r\n\r\n  /**\r\n   * The names of all asynchronous validations currently running for the\r\n   * form group.\r\n   */\r\n  pendingValidations: string[];\r\n\r\n  /**\r\n   * This property indicates whether the group or any of its children\r\n   * are currently being asynchronously validated.\r\n   */\r\n  isValidationPending: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the form group is enabled. It is\r\n   * `true` if and only if at least one of its child states is\r\n   * enabled. When it is `false` the `errors` are always `{}` (i.e.\r\n   * the form group is always valid if disabled) and `pendingValidations`\r\n   * is always `[]` (i.e. all pending validations are cancelled).\r\n   */\r\n  isEnabled: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the form group is disabled. It is\r\n   * `true` if and only if all of its child state are disabled. When\r\n   * it is `true` the `errors` are always `{}` (i.e. the form group\r\n   * is always valid if disabled) and `pendingValidations` is always\r\n   * `[]` (i.e. all pending validations are cancelled).\r\n   */\r\n  isDisabled: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if at least one of the form\r\n   * group's child states is marked as dirty.\r\n   */\r\n  isDirty: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if all of the form group's\r\n   * child states are pristine.\r\n   */\r\n  isPristine: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if at least one of the form\r\n   * group's child states is marked as touched.\r\n   */\r\n  isTouched: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if all of the form group's\r\n   * child states are untouched.\r\n   */\r\n  isUntouched: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the form group is\r\n   * submitted. This is tracked by the `NgrxFormDirective`, which\r\n   * needs to be applied to a form like this:\r\n   *\r\n   * ```html\r\n   * <form [ngrxFormState]=\"groupState\">\r\n   * </form>\r\n   * ```\r\n   *\r\n   * Note that applying this directive to a form prevents normal form\r\n   * submission since that does not make much sense for ngrx forms.\r\n   */\r\n  isSubmitted: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the state is not submitted.\r\n   */\r\n  isUnsubmitted: boolean;\r\n\r\n  /**\r\n   * This property contains all child states of the form group. As\r\n   * you may have noticed the type of each child state is\r\n   * `AbstractControlState` which sometimes forces you to cast the\r\n   * state explicitly. It is not possible to improve this typing\r\n   * until [conditional mapped types](https://github.com/Microsoft/TypeScript/issues/12424)\r\n   * are added to TypeScript.\r\n   */\r\n  controls: FormGroupControls<TValue>;\r\n}\r\n\r\n/**\r\n * Form arrays are collections of controls. They are represented as\r\n * plain state arrays. The state of an array is determined almost\r\n * fully by its child states.\r\n */\r\nexport interface FormArrayState<TValue> extends AbstractControlState<TValue[]> {\r\n  /**\r\n   * The aggregated value of the form array. The value is computed by\r\n   * aggregating the values of all children into an array.\r\n   */\r\n  value: TValue[];\r\n\r\n  /**\r\n   * This property is `true` if the form array does not have any errors\r\n   * itself and none of its children have any errors.\r\n   */\r\n  isValid: boolean;\r\n\r\n  /**\r\n   * This property is `true` if the form array or any of its children\r\n   * have at least one error.\r\n   */\r\n  isInvalid: boolean;\r\n\r\n  /**\r\n   * The errors of the form array. This property is computed by merging\r\n   * the errors of the array with the errors of all its children where\r\n   * the child errors are a property of the `errors` object prefixed with\r\n   * an underscore, e.g.\r\n   *\r\n   * ```\r\n   * {\r\n   *   arrayError: true,\r\n   *   _0: {\r\n   *     childError: true,\r\n   *   },\r\n   * }\r\n   * ```\r\n   *\r\n   * If neither the array nor any children have errors the property is\r\n   * set to `{}`.\r\n   */\r\n  errors: ValidationErrors;\r\n\r\n  /**\r\n   * The names of all asynchronous validations currently running for the\r\n   * form array.\r\n   */\r\n  pendingValidations: string[];\r\n\r\n  /**\r\n   * This property indicates whether the array or any of its children\r\n   * are currently being asynchronously validated.\r\n   */\r\n  isValidationPending: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the form array is enabled. It is\r\n   * `true` if and only if at least one of its child states is\r\n   * enabled. When it is `false` the `errors` are always `{}` (i.e.\r\n   * the form array is always valid if disabled) and `pendingValidations`\r\n   * is always `[]` (i.e. all pending validations are cancelled).\r\n   */\r\n  isEnabled: boolean;\r\n\r\n  /**\r\n   * This property indicates whether the form array is disabled. It is\r\n   * `true` if and only if all of its child states are disabled. When\r\n   * it is `true` the `errors` are always `{}` (i.e. the form array\r\n   * is always valid if disabled) and `pendingValidations` is always\r\n   * `[]` (i.e. all pending validations are cancelled).\r\n   */\r\n  isDisabled: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if at least one of the form\r\n   * array's child states is marked as dirty.\r\n   */\r\n  isDirty: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if all of the form array's\r\n   * child states are pristine.\r\n   */\r\n  isPristine: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if at least one of the form\r\n   * array's child states is marked as touched.\r\n   */\r\n  isTouched: boolean;\r\n\r\n  /**\r\n   * This property is `true` if and only if all of the form array's\r\n   * child states are untouched.\r\n   */\r\n  isUntouched: boolean;\r\n\r\n  /**\r\n   * This property is set to `true` as soon as the form array is\r\n   * submitted. This is tracked by the `NgrxFormDirective`, which\r\n   * needs to be applied to a form like this:\r\n   *\r\n   * ```html\r\n   * <form [ngrxFormState]=\"arrayState\">\r\n   * </form>\r\n   * ```\r\n   *\r\n   * Note that applying this directive to a form prevents normal form\r\n   * submission since that does not make much sense for ngrx forms.\r\n   */\r\n  isSubmitted: boolean;\r\n\r\n  /**\r\n   * This property is `true` as long as the state is not submitted.\r\n   */\r\n  isUnsubmitted: boolean;\r\n\r\n  /**\r\n   * This property contains all child states of the form array. As\r\n   * you may have noticed the type of each child state is\r\n   * `AbstractControlState` which sometimes forces you to cast the\r\n   * state explicitly. It is not possible to improve this typing\r\n   * until [conditional mapped types](https://github.com/Microsoft/TypeScript/issues/12424)\r\n   * are added to TypeScript.\r\n   */\r\n  controls: Array<AbstractControlState<TValue>>;\r\n}\r\n\r\n/**\r\n * This function determines if a form state is an array state.\r\n */\r\nexport function isArrayState(state: AbstractControlState<any>): state is FormArrayState<any> {\r\n  const controls = (state as any).controls;\r\n  return state.hasOwnProperty('controls') && Array.isArray(controls) && typeof controls !== 'function';\r\n}\r\n\r\n/**\r\n * This function determines if a form state is a group state.\r\n */\r\nexport function isGroupState(state: AbstractControlState<any>): state is FormGroupState<any> {\r\n  const controls = (state as any).controls;\r\n  return state.hasOwnProperty('controls') && !Array.isArray(controls) && typeof controls !== 'function';\r\n}\r\n\r\n/**\r\n * This utility function allows the compiler to correctly infer\r\n * the type of a form state. It can be used in places where a\r\n * sub-type of `AbstractControlState` is expected.\r\n */\r\nexport function cast<TValue extends FormControlValueTypes>(\r\n  state: AbstractControlState<TValue>,\r\n): FormControlState<TValue>;\r\n\r\n/**\r\n * This utility function allows the compiler to correctly infer\r\n * the type of a form state. It can be used in places where a\r\n * sub-type of `AbstractControlState` is expected.\r\n */\r\nexport function cast<TArray extends TValue[], TValue = any>(\r\n  state: AbstractControlState<TArray>,\r\n): FormArrayState<TValue>;\r\n\r\n/**\r\n * This utility function allows the compiler to correctly infer\r\n * the type of a form state. It can be used in places where a\r\n * sub-type of `AbstractControlState` is expected.\r\n */\r\nexport function cast<TArray extends TValue[], TValue = any>(\r\n  state: AbstractControlState<TArray | undefined>,\r\n): FormArrayState<TValue> | undefined;\r\n\r\n/**\r\n * This utility function allows the compiler to correctly infer\r\n * the type of a form state. It can be used in places where a\r\n * sub-type of `AbstractControlState` is expected.\r\n */\r\nexport function cast<TValue extends KeyValue>(\r\n  state: AbstractControlState<TValue>,\r\n): FormGroupState<TValue>;\r\n\r\n/**\r\n * This utility function allows the compiler to correctly infer\r\n * the type of a form state. It can be used in places where a\r\n * sub-type of `AbstractControlState` is expected.\r\n */\r\nexport function cast<TValue extends KeyValue>(\r\n  state: AbstractControlState<TValue | undefined>,\r\n): FormGroupState<TValue> | undefined;\r\n\r\n/**\r\n * This utility function allows the compiler to correctly infer\r\n * the type of a form state. It can be used in places where a\r\n * sub-type of `AbstractControlState` is expected.\r\n */\r\nexport function cast<TValue>(\r\n  state: AbstractControlState<TValue>,\r\n) {\r\n  return state as any;\r\n}\r\n\r\nexport function createChildState(id: string, childValue: any): AbstractControlState<any> {\r\n  if (childValue !== null && Array.isArray(childValue)) {\r\n    return createFormArrayState(id, childValue);\r\n  }\r\n\r\n  if (childValue !== null && typeof childValue === 'object') {\r\n    return createFormGroupState(id, childValue);\r\n  }\r\n\r\n  return createFormControlState(id, childValue);\r\n}\r\n\r\n/**\r\n * This function creates a form control state with an ID and a value.\r\n */\r\nexport function createFormControlState<TValue extends FormControlValueTypes>(\r\n  id: NgrxFormControlId,\r\n  value: TValue,\r\n): FormControlState<TValue> {\r\n  return {\r\n    id,\r\n    value,\r\n    errors: {},\r\n    pendingValidations: [],\r\n    isValidationPending: false,\r\n    isValid: true,\r\n    isInvalid: false,\r\n    isEnabled: true,\r\n    isDisabled: false,\r\n    isDirty: false,\r\n    isPristine: true,\r\n    isTouched: false,\r\n    isUntouched: true,\r\n    isSubmitted: false,\r\n    isUnsubmitted: true,\r\n    isFocused: false,\r\n    isUnfocused: true,\r\n    userDefinedProperties: {},\r\n  };\r\n}\r\n\r\nexport function getFormGroupValue<TValue extends { [key: string]: any }>(\r\n  controls: FormGroupControls<TValue>,\r\n  originalValue: TValue,\r\n): TValue {\r\n  let hasChanged = Object.keys(originalValue).length !== Object.keys(controls).length;\r\n  const newValue = Object.keys(controls).reduce((res, key) => {\r\n    hasChanged = hasChanged || originalValue[key] !== controls[key].value;\r\n    res[key] = controls[key].value;\r\n    return res;\r\n  }, {} as TValue);\r\n\r\n  return hasChanged ? newValue : originalValue;\r\n}\r\n\r\nexport function getFormGroupErrors<TValue extends object>(\r\n  controls: FormGroupControls<TValue>,\r\n  originalErrors: ValidationErrors,\r\n): ValidationErrors {\r\n  let hasChanged = false;\r\n  const groupErrors =\r\n    Object.keys(originalErrors)\r\n      .filter(key => !key.startsWith('_'))\r\n      .reduce((res, key) => Object.assign(res, { [key]: originalErrors[key] }), {});\r\n\r\n  const newErrors = Object.keys(controls).reduce((res, key: any) => {\r\n    const controlErrors = controls[key].errors;\r\n    if (!isEmpty(controlErrors)) {\r\n      hasChanged = hasChanged || originalErrors['_' + key] !== controlErrors;\r\n      res['_' + key] = controls[key].errors;\r\n    } else {\r\n      hasChanged = hasChanged || originalErrors.hasOwnProperty('_' + key);\r\n    }\r\n\r\n    return res;\r\n  }, groupErrors as ValidationErrors);\r\n\r\n  hasChanged = hasChanged || Object.keys(originalErrors).length !== Object.keys(newErrors).length;\r\n\r\n  return hasChanged ? newErrors : originalErrors;\r\n}\r\n\r\nexport function computeGroupState<TValue extends KeyValue>(\r\n  id: string,\r\n  controls: FormGroupControls<TValue>,\r\n  value: TValue,\r\n  errors: ValidationErrors,\r\n  pendingValidations: string[],\r\n  userDefinedProperties: KeyValue,\r\n): FormGroupState<TValue> {\r\n  value = getFormGroupValue<TValue>(controls, value);\r\n  errors = getFormGroupErrors(controls, errors);\r\n  const isValid = isEmpty(errors);\r\n  const isDirty = Object.keys(controls).some(key => controls[key].isDirty);\r\n  const isEnabled = Object.keys(controls).length === 0 || Object.keys(controls).some(key => controls[key].isEnabled);\r\n  const isTouched = Object.keys(controls).some(key => controls[key].isTouched);\r\n  const isSubmitted = Object.keys(controls).some(key => controls[key].isSubmitted);\r\n  const isValidationPending = pendingValidations.length > 0 || Object.keys(controls).some(key => controls[key].isValidationPending);\r\n  return {\r\n    id,\r\n    value,\r\n    errors,\r\n    pendingValidations,\r\n    isValidationPending,\r\n    isValid,\r\n    isInvalid: !isValid,\r\n    isEnabled,\r\n    isDisabled: !isEnabled,\r\n    isDirty,\r\n    isPristine: !isDirty,\r\n    isTouched,\r\n    isUntouched: !isTouched,\r\n    isSubmitted,\r\n    isUnsubmitted: !isSubmitted,\r\n    userDefinedProperties,\r\n    controls,\r\n  };\r\n}\r\n\r\n/**\r\n * This function creates a form group state with an ID and a value.\r\n * From the value the shape of the group state is inferred, i.e.\r\n * object properties are inferred as form groups, array properties\r\n * are inferred as form arrays, and primitive properties are inferred\r\n * as form controls.\r\n */\r\nexport function createFormGroupState<TValue extends KeyValue>(\r\n  id: NgrxFormControlId,\r\n  initialValue: TValue,\r\n): FormGroupState<TValue> {\r\n  const controls = Object.keys(initialValue)\r\n    .map((key: keyof TValue) => [key, createChildState(`${id}.${key}`, initialValue[key])] as [string, AbstractControlState<any>])\r\n    .reduce((res, [controlId, state]) => Object.assign(res, { [controlId]: state }), {} as FormGroupControls<TValue>);\r\n\r\n  return computeGroupState(id, controls, initialValue, {}, [], {});\r\n}\r\n\r\nexport function getFormArrayValue<TValue>(\r\n  controls: Array<AbstractControlState<TValue>>,\r\n  originalValue: TValue[],\r\n): TValue[] {\r\n  let hasChanged = Object.keys(originalValue).length !== Object.keys(controls).length;\r\n  const newValue = controls.map((state, i) => {\r\n    hasChanged = hasChanged || originalValue[i] !== state.value;\r\n    return state.value;\r\n  });\r\n\r\n  return hasChanged ? newValue : originalValue;\r\n}\r\n\r\nexport function getFormArrayErrors<TValue>(\r\n  controls: Array<AbstractControlState<TValue>>,\r\n  originalErrors: ValidationErrors,\r\n): ValidationErrors {\r\n  let hasChanged = false;\r\n  const groupErrors =\r\n    Object.keys(originalErrors)\r\n      .filter(key => !key.startsWith('_'))\r\n      .reduce((res, key) => Object.assign(res, { [key]: originalErrors[key] }), {});\r\n\r\n  const newErrors = controls.reduce((res, state, i) => {\r\n    const controlErrors = state.errors;\r\n    if (!isEmpty(controlErrors)) {\r\n      hasChanged = hasChanged || originalErrors['_' + i] !== controlErrors;\r\n      res['_' + i] = controlErrors;\r\n    } else {\r\n      hasChanged = hasChanged || originalErrors.hasOwnProperty('_' + i);\r\n    }\r\n\r\n    return res;\r\n  }, groupErrors as ValidationErrors);\r\n\r\n  hasChanged = hasChanged || Object.keys(originalErrors).length !== Object.keys(newErrors).length;\r\n\r\n  return hasChanged ? newErrors : originalErrors;\r\n}\r\n\r\nexport function computeArrayState<TValue>(\r\n  id: string,\r\n  controls: Array<AbstractControlState<TValue>>,\r\n  value: TValue[],\r\n  errors: ValidationErrors,\r\n  pendingValidations: string[],\r\n  userDefinedProperties: KeyValue,\r\n): FormArrayState<TValue> {\r\n  value = getFormArrayValue<TValue>(controls, value);\r\n  errors = getFormArrayErrors(controls, errors);\r\n  const isValid = isEmpty(errors);\r\n  const isDirty = controls.some(state => state.isDirty);\r\n  const isEnabled = controls.length === 0 || controls.some(state => state.isEnabled);\r\n  const isTouched = controls.some(state => state.isTouched);\r\n  const isSubmitted = controls.some(state => state.isSubmitted);\r\n  const isValidationPending = pendingValidations.length > 0 || controls.some(state => state.isValidationPending);\r\n  return {\r\n    id,\r\n    value,\r\n    errors,\r\n    pendingValidations,\r\n    isValidationPending,\r\n    isValid,\r\n    isInvalid: !isValid,\r\n    isEnabled,\r\n    isDisabled: !isEnabled,\r\n    isDirty,\r\n    isPristine: !isDirty,\r\n    isTouched,\r\n    isUntouched: !isTouched,\r\n    isSubmitted,\r\n    isUnsubmitted: !isSubmitted,\r\n    userDefinedProperties,\r\n    controls,\r\n  };\r\n}\r\n\r\n/**\r\n * This function creates a form array state with an ID and a value.\r\n * From the value the shape of the array state is inferred, i.e.\r\n * object values are inferred as form groups, array values\r\n * are inferred as form arrays, and primitive values are inferred\r\n * as form controls.\r\n */\r\nexport function createFormArrayState<TValue>(\r\n  id: NgrxFormControlId,\r\n  initialValue: TValue[],\r\n): FormArrayState<TValue> {\r\n  const controls = initialValue\r\n    .map((value, i) => createChildState(`${id}.${i}`, value) as AbstractControlState<TValue>);\r\n\r\n  return computeArrayState(id, controls, initialValue, {}, [], {});\r\n}\r\n"]}